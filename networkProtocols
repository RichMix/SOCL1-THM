# DHCP

You went to your favourite coffee shop, grabbed your favourite hot drink, and opened your laptop. 
Your laptop connected to the shop’s WiFi and automatically configured the network, so you could now work on a new TryHackMe room. 
You didn’t type a single IP address, yet your device is all set up. Let’s see how this happened.

Whenever we want to access a network, at the very least, we need to configure the following:

IP address along with subnet mask
Router (or gateway)
DNS server
Whenever we connect our device to a new network, the above configurations must be set according to the new network. Manually configuring these settings is a good option, especially for servers. Servers are not expected to switch networks; you don’t carry your domain controller and connect it to the coffee shop WiFi. Moreover, other devices need to connect to the servers and expect to find them at specific IP addresses.

Having an automated way to configure connected devices has many advantages. First, it would save us from manually configuring the network; this is extremely important, especially for mobile devices. Secondly, it saves us from address conflicts, i.e., when two devices are configured with the same IP address. An IP address conflict would prevent the involved hosts from using the network resources; this applies to local resources and the Internet. The solution lies in using Dynamic Host Configuration Protocol (DHCP). DHCP is an application-level protocol that relies on UDP; the server listens on UDP port 67, and the client sends from UDP port 68. Your smartphone and laptop are configured to use DHCP by default.

In the DHCP protocol, DORA stands for Discover, Offer, Request, and Acknowledge.

DHCP follows four steps: Discover, Offer, Request, and Acknowledge (DORA):

DHCP Discover: The client broadcasts a DHCPDISCOVER message seeking the local DHCP server if one exists.
DHCP Offer: The server responds with a DHCPOFFER message with an IP address available for the client to accept.
DHCP Request: The client responds with a DHCPREQUEST message to indicate that it has accepted the offered IP.
DHCP Acknowledge: The server responds with a DHCPACK message to confirm that the offered IP address is now assigned to this client.
A laptop sends a DHCP Discover, the server responds with a DHCP Offer, the laptop responds with a DHCP Request, and finally, the server responds with a DHCP Acknowledge.

The following packet capture shows the four steps explained above. In this example, the client gets the address 192.168.66.133.

Terminal
user@TryHackMe$ tshark -r DHCP-G5000.pcap -n
    1   0.000000      0.0.0.0 → 255.255.255.255 DHCP 342 DHCP Discover - Transaction ID 0xfb92d53f
    2   0.013904 192.168.66.1 → 192.168.66.133 DHCP 376 DHCP Offer    - Transaction ID 0xfb92d53f
    3   4.115318      0.0.0.0 → 255.255.255.255 DHCP 342 DHCP Request  - Transaction ID 0xfb92d53f
    4   4.228117 192.168.66.1 → 192.168.66.133 DHCP 376 DHCP ACK      - Transaction ID 0xfb92d53f
In the DHCP packet exchange, we can notice the following:

The client starts without any IP network configuration. It only has a MAC address. 
In the first and third packets, DHCP Discover and DHCP Request, the client searching for a DHCP server still has no IP network configuration and has not yet used the DHCP server’s offered IP address. 
Therefore, it sends packets from the IP address 0.0.0.0 to the broadcast IP address 255.255.255.255.
As for the link layer, in the first and third packets, the client sends to the broadcast MAC address, ff:ff:ff:ff:ff:ff (not shown in the output above). 
The DHCP server offers an available IP address along with the network configuration in the DHCP offer. It uses the client’s destination MAC address. (It used the proposed IP address in this example system.)
At the end of the DHCP process, our device would have received all the configuration needed to access the network or even the Internet. 
In particular, we expect that the DHCP server has provided us with the following:

The leased IP address to access network resources
The gateway to route our packets outside the local network
A DNS server to resolve domain names (more on this later)



# ARP

We have stated in the Networking Concepts room that as two hosts communicate over a network, an IP packet is encapsulated within a data link frame as it travels over layer 2. Remember that the two common data link layers we use are Ethernet (IEEE 802.3) and WiFi (IEEE 802.11). Whenever one host needs to communicate with another host on the same Ethernet or WiFi, it must send the IP packet within a data link layer frame. Although it knows the IP address of the target host, it needs to look up the target’s MAC address so the proper data link header can be created.

As you would remember, a MAC address is a 48-bit number typically represented in hexadecimal notation; for example, 7C:DF:A1:D3:8C:5C and 44:DF:65:D8:FE:6C are two MAC addresses on my network.

However, the devices on the same Ethernet network do not need to know each other’s MAC addresses all the time; they only need to know each other’s MAC addresses while communicating. Everything revolves around IP addresses. Consider this scenario: You connect your device to a network, and if the network has a DHCP server, your device is automatically configured to use a specific gateway (router) and DNS server. Consequently, your device knows the IP address of the DNS server to resolve any domain name; moreover, it knows the IP address of the router when it needs to send packets over the Internet. In all this scenario, no MAC addresses are revealed. However, two devices on the same Ethernet cannot communicate without knowing each other’s MAC addresses.

As a reminder, in the screenshot below, we see an IP packet within an Ethernet frame. The Ethernet frame header contains:

Destination MAC address
Source MAC address
Type (IPv4 in this case)
Wireshark showing the destination MAC address, source MAC address, and the protocol type in an Ethernet frame. The IP packet is encapsulated within this Ethernet frame.

Address Resolution Protocol (ARP) makes it possible to find the MAC address of another device on the Ethernet. 
In the example below, a host with the IP address 192.168.66.89 wants to communicate with another system with the IP address 192.168.66.1. 
It sends an ARP Request asking the host with the IP address 192.168.66.1 to respond. 
The ARP Request is sent from the MAC address of the requester to the broadcast MAC address, ff:ff:ff:ff:ff:ff as shown in the first packet. The ARP Reply arrived shortly afterwards, and the host with the IP address 192.168.66.1 responded with its MAC address. From this point, the two hosts can exchange data link layer frames.

Terminal
user@TryHackMe$ tshark -r arp.pcapng -Nn
    1 0.000000000 cc:5e:f8:02:21:a7 → ff:ff:ff:ff:ff:ff ARP 42 Who has 192.168.66.1? Tell 192.168.66.89
    2 0.003566632 44:df:65:d8:fe:6c → cc:5e:f8:02:21:a7 ARP 42 192.168.66.1 is at 44:df:65:d8:fe:6c
If we use tcpdump, the packets will be displayed differently. 
It uses the terms ARP Request and ARP Reply.
For your information, the output is shown in the terminal below.

Terminal
user@TryHackMe$ tcpdump -r arp.pcapng -n -v
17:23:44.506615 ARP, Ethernet (len 6), IPv4 (len 4), Request who-has 192.168.66.1 tell 192.168.66.89, length 28
17:23:44.510182 ARP, Ethernet (len 6), IPv4 (len 4), Reply 192.168.66.1 is-at 44:df:65:d8:fe:6c, length 28
An ARP Request or ARP Reply is not encapsulated within a UDP or even IP packet; it is encapsulated directly within an Ethernet frame. 
The following ARP Reply shows this.

Wireshark showing an ARP Reply encapsulated directly within an Ethernet frame.

ARP is considered layer 2 because it deals with MAC addresses. 
Others would argue that it is part of layer 3 because it supports IP operations. 
What is essential to know is that ARP allows the translation from layer 3 addressing to layer 2 addressing.

